# 5. Frontend Implementation Plan

## 5.1. Directory Structure
All frontend code will reside within the `axis-interactive-timing-editor/` directory. The final data file will be placed in `axis-interactive-timing-editor/public/` to be easily served.

- `axis-interactive-timing-editor/`
  - `public/`
    - `scene_data.json` (Generated by backend)
  - `src/`
    - `App.tsx` (To be simplified by the user)
    - `index.html` (Entry point)
    - `visualizer.js` (Core logic, to be created/implemented)
    - `style.css` (Styling)

## 5.2. `App.tsx` Modification (User's Task)
The user will be guided to replace the content of `App.tsx` with a minimal version, as the complex state management for editing is not needed for the Phase 1 viewer. The new `App.tsx` will essentially be an empty shell, as all logic will be handled by vanilla JavaScript in `visualizer.js`.

**Simplified `App.tsx` Code:**
```tsx
import React from 'react';

function App() {
  // All visualization logic is now handled by visualizer.js,
  // which directly manipulates the DOM elements defined in index.html.
  // This React component serves only as a project entry point.
  return null;
}

export default App;
```
*Note: The user's `index.html` must load `visualizer.js` via a `<script>` tag for this to work.*

## 5.3. `visualizer.js` Implementation

This new file will contain all the client-side logic.

### 5.3.1. Global Variables
```javascript
let video;
let canvas;
let ctx;
let playPauseBtn;
let scrubBar;
let frameCounter;

let visualizationData = []; // Will hold the array from scene_data.json
let colorMap = {}; // Caches a unique color for each line ID
let videoMetadataLoaded = false;
```

### 5.3.2. `init()` Function
- **Trigger:** `DOMContentLoaded` event.
- **Logic:**
  - Get all DOM elements by ID and assign them to the global variables.
  - Call `loadData()`.
  - Add event listeners for UI controls (`playPauseBtn`, `scrubBar`).

### 5.3.3. `loadData()` Function
- **Trigger:** Called by `init()`.
- **Logic:**
  - Use the `fetch` API to get `./scene_data.json`.
  - Parse the response as JSON and store it in the `visualizationData` array.
  - Add a `loadedmetadata` event listener to the `video` element. When triggered:
    - Set `canvas.width = video.videoWidth`.
    - Set `canvas.height = video.videoHeight`.
    - Set `scrubBar.max` to `visualizationData.length - 1`.
    - Set `videoMetadataLoaded = true`.

### 5.3.4. `drawFrame(frameIndex)` Function
- **Trigger:** Called by the main render loop and UI event listeners.
- **Input:** `frameIndex` (integer).
- **Logic:**
  - If `videoMetadataLoaded` is false, or `visualizationData` is empty, return.
  - Clear the canvas: `ctx.clearRect(0, 0, canvas.width, canvas.height)`.
  - Find the corresponding frame's data: `const frameData = visualizationData[frameIndex]`.
  - If `frameData` exists, loop through `frameData.lines`.
  - For each `line`:
    - Get a consistent color using `getLineColor(line.id)`.
    - Set `ctx.strokeStyle` and `ctx.lineWidth`.
    - Use `ctx.beginPath()`, `ctx.moveTo()`, and `ctx.lineTo()` to draw the segments defined in `line.points`.
    - Call `ctx.stroke()`.
  - Update the frame counter text: `frameCounter.textContent = 
Frame: ${frameIndex}
`;.

### 5.3.5. `getLineColor(lineId)` Function
- **Input:** `lineId` (number).
- **Output:** A CSS color string.
- **Logic:**
  - Check if `colorMap[lineId]` exists. If so, return it.
  - If not, generate a new random HSL color string (e.g., `hsl(${Math.random() * 360}, 100%, 50%)`), store it in `colorMap[lineId]`, and return it.

### 5.3.6. `renderLoop()` Function
- **Trigger:** Called when the video plays.
- **Logic:**
  - If the video is not paused:
    - Calculate the current frame index: `const frameIndex = Math.floor(video.currentTime * 30);` (assuming 30fps).
    - Call `drawFrame(frameIndex)`.
    - Update the scrub bar value: `scrubBar.value = frameIndex`.
    - Call `requestAnimationFrame(renderLoop)` to schedule the next loop.

### 5.3.7. Event Listeners
- **`playPauseBtn` 'click'**: Toggles `video.play()` and `video.pause()`. If playing, it also initiates the `renderLoop()`. Updates the button text.
- **`scrubBar` 'input'**: When the user drags the slider:
  - `const frameIndex = parseInt(scrubBar.value, 10)`.
  - `video.currentTime = frameIndex / 30`.
  - `drawFrame(frameIndex)`.
