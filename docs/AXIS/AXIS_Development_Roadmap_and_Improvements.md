# AXIS 개발 로드맵 및 개선 계획

## 1. 개요

이 문서는 AXIS 모듈의 초기 설계 및 문서화 단계에 대한 자체 피드백을 바탕으로, 식별된 개선점들을 해결하기 위한 구체적인 실행 계획을 정의합니다. 이 계획의 목표는 현재의 프로토타입 설계를 운영 가능한(Production-ready) 수준의 견고한 시스템으로 발전시키는 것입니다.

---

## 2. 시각 자료 보강 계획

- **문제점**: 현재 문서는 대부분 텍스트 기반으로, 시스템의 복잡한 구조와 데이터 흐름을 직관적으로 파악하기 어렵습니다.

- **해결 방안**:
  1.  **도구 선정**: 표준 다이어그램 도구인 **`draw.io`** (VSCode 확장 프로그램 또는 웹 버전)를 사용하여 시각 자료를 제작합니다.
  2.  **자료 저장**: 생성된 다이어그램의 `png` 파일과 수정 가능한 `drawio` 원본 파일은 `docs/images/` 디렉토리 내에 저장하고, 관련 문서에 이미지를 삽입합니다.
  3.  **제작할 다이어그램 리스트**:
      - **시스템 컨텍스트 다이어그램 (C4 Model - Level 1)**: TALOS 시스템과 외부 사용자(애니메이터), 외부 시스템 간의 관계를 표현합니다.
      - **컨테이너 다이어그램 (C4 Model - Level 2)**: `Orchestrator`, `PRISM`, `AXIS`, `CHROMA`, `Shared Data Store` 등 주요 컴포넌트들이 API와 데이터로 어떻게 상호작용하는지 시각화합니다.
      - **AXIS 내부 컴포넌트 다이어그램**: `Pipeline`, `ProcessingStep`, `Strategy` 등 AXIS 모듈 내부의 주요 클래스 간의 관계를 표현합니다.
      - **시퀀스 다이어그램**: '프롬프트 기반 전체 애니메이션 생성' 유즈케이스에 대한 모듈 간 API 호출 및 콜백 순서를 시간 흐름에 따라 시각화합니다.

---

## 3. 설정 관리(Configuration Management) 도입 방안

- **문제점**: 모델 파일 경로, API 키, 각종 임계값(threshold) 등 주요 설정값들이 코드에 하드코딩될 경우, 유지보수와 배포 환경 관리가 매우 어려워집니다.

- **해결 방안**:
  1.  **라이브러리 도입**: **`Pydantic-settings`** 라이브러리를 도입하여, 타입 검증이 가능하고 계층적인 설정 관리를 표준화합니다.
  2.  **계층적 설정 구조 설계**:
      - **`config.yaml`**: 프로젝트 루트에 기본 설정값(기본 모델 경로, 처리 해상도, 기본 임계값 등)을 정의합니다.
      - **환경 변수 (Environment Variables)**: Docker/Kubernetes와 같은 컨테이너 환경에서의 배포를 위해, API 키, 데이터베이스 주소, 스토리지 접속 정보 등 민감하거나 환경에 따라 달라지는 정보는 환경 변수로 덮어쓸 수 있도록 합니다.
      - **`Settings` 클래스 구현**: `Pydantic-settings`를 사용하여 `config.yaml` 파일과 환경 변수를 자동으로 읽어와, 타입 검증까지 수행하는 중앙 `Settings` 클래스를 `src/config.py` 와 같은 파일에 정의합니다.

---

## 4. 에러 처리 및 복원력(Resilience) 설계

- **문제점**: 현재 설계는 주로 '성공 시나리오'에 집중되어 있어, 실패 상황에서의 시스템 동작이 정의되지 않았습니다.

- **해결 방안**:
  1.  **단계별 재시도 정책 (Step-level Retry Policy)**: `Orchestrator`는 특정 모듈(예: AXIS) 호출이 실패했을 때, 일시적인 오류(네트워크 문제, 일시적 서버 오류 등)를 감안하여 지정된 횟수(예: 3회)와 간격(예: Exponential Backoff)으로 재시도를 수행하는 로직을 구현합니다.
  2.  **Dead Letter Queue (DLQ) 개념 도입**: 수차례의 재시도에도 불구하고 계속 실패하는 작업은 최종 '실패' 상태로 변경하고, 실패 원인과 당시의 입력 데이터(Request Body)를 별도의 로그 또는 메시지 큐에 기록하여 사후 분석 및 수동 재처리(필요시)가 가능하도록 합니다.
  3.  **명확한 API 에러 코드 정의**: 각 모듈의 API는 실패 시, 원인을 명확히 알 수 있는 HTTP 상태 코드와 에러 메시지를 반환하도록 규정합니다.
      - `400 Bad Request`: 입력값(URL, 파라미터)이 유효하지 않음.
      - `422 Unprocessable Entity`: 입력값의 형식은 맞으나, 내용이 비즈니스 로직상 처리 불가능함.
      - `503 Service Unavailable`: 모델 로딩 실패 등 내부의 일시적인 문제로 현재 요청을 처리할 수 없음.

---

## 5. 성능 벤치마킹 계획

- **문제점**: "빠르다", "느리다"를 판단할 객관적인 성능 목표와 측정 방법이 없습니다.

- **해결 방안**:
  1.  **성능 목표(Target) 정의**: 초기 프로토타입에 대한 구체적인 성능 목표를 설정합니다. (예: "표준 테스트 영상(10초, FHD, 240프레임)을 NVIDIA A100 GPU 1대 환경에서 10분 이내에 처리 완료").
  2.  **프로파일링 기능 구현**: `Pipeline` 클래스를 수정하여, 각 `ProcessingStep`의 실행 시작과 끝에 시간을 측정하는 로직을 추가합니다. 이 결과는 `MetricsLogger` 옵저버를 통해 구조화된 로그로 기록되어, 어떤 단계가 병목 구간인지 쉽게 식별할 수 있도록 합니다.
  3.  **지속적인 성능 테스트 자동화**: GitHub Actions와 같은 CI/CD 파이프라인에 성능 테스트 스크립트를 통합합니다. 새로운 코드가 주 브랜치에 병합되기 전에, 표준 테스트 영상에 대한 성능 테스트를 자동으로 실행하고, 기존 대비 성능이 크게 저하되었을 경우 경고를 발생시키거나 병합을 차단하는 규칙을 설정합니다.
