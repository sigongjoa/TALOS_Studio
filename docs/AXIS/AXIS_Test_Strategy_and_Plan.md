# AXIS 모듈 테스트 전략 및 계획

## 1. 테스트의 정의 및 목적

### 1.1. 정의

본 문서에서 "테스트"란, AXIS 모듈을 구성하는 각 기능 단위(함수, 클래스)와 전체 파이프라인이 주어진 요구사항과 설계 명세에 따라 정확하고 안정적으로 작동하는지 검증하는 모든 활동을 의미한다.

### 1.2. 목적

- **정확성 검증**: 각 알고리즘(예: 3D 역투영, 라인 추적)이 논리적, 수학적으로 올바른 결과를 출력하는지 확인한다.
- **안정성 확보 (회귀 방지)**: 새로운 코드 변경 또는 리팩토링 이후에도 기존 기능이 의도치 않게 손상되지 않았음을 보장한다.
- **일관성 보장**: 동일한 입력에 대해 항상 동일한 출력을 내보내는지(결정론적 동작) 확인한다.
- **성능 측정 기반 마련**: 파이프라인의 각 단계가 허용 가능한 시간 및 리소스 내에서 작업을 완료하는지 측정하고, 성능 저하를 추적할 수 있는 기반을 마련한다.

## 2. 테스트 환경 셋팅

### 2.1. 기술 스택

- **테스트 프레임워크**: `pytest` - Python 생태계의 표준 테스트 러너로, 간결한 문법과 강력한 기능을 제공한다.
- **의존성 격리 (Mocking)**: `unittest.mock` - Python 표준 라이브러리에 내장된 기능으로, 외부 API 호출이나 무거운 의존성을 모의(Mock) 객체로 대체하여 테스트의 속도와 독립성을 확보한다.
- **코드 커버리지 측정**: `pytest-cov` - `pytest` 플러그인으로, 테스트가 코드의 몇 퍼센트를 실행하는지 측정하여 테스트의 완전성을 평가하는 데 도움을 준다.

### 2.2. 환경 구성

- **테스트용 의존성 관리**: 프로젝트 루트에 `requirements-test.txt` 파일을 생성하여 테스트에만 필요한 라이브러리를 명시한다.
  ```txt
  # requirements-test.txt
  pytest
  pytest-cov
  ```

- **테스트 데이터 관리**: `AXIS/tests/data/` 디렉토리를 생성하여, 테스트에 사용할 작은 이미지, 비디오 클립(1~2초), 설정 파일, '정답' 결과 파일 등 고정된 데이터 자산을 관리한다. 이를 통해 모든 환경에서 재현 가능한 테스트를 보장한다.

- **테스트 실행**: `pytest --cov=src tests/` 와 같은 명령어로 `tests` 디렉토리 하위의 모든 테스트를 실행하고, `src` 디렉토리에 대한 코드 커버리지를 측정한다.

## 3. 테스트 진행 방향 및 종류

AXIS 모듈의 테스트는 세 가지 계층으로 구성된다.

### 3.1. 단위 테스트 (Unit Tests)

- **대상**: 단일 함수, 메소드, 클래스 등 가장 작은 코드 단위. 주로 `src/strategies/` 와 유틸리티 함수들이 해당된다.
- **목표**: 각 부품의 논리적 정확성을 검증한다. 외부 의존성(파일 시스템, 네트워크, 무거운 모델 등)은 모두 Mock 처리하여 빠르고 독립적으로 실행되도록 한다.
- **예시**:
    - `backproject_to_3d` 함수에 고정된 2D 좌표, Depth, 카메라 행렬을 입력하고, 예상되는 3D 좌표와 정확히 일치하는지 `np.testing.assert_allclose`로 검증한다.
    - `MiDaSEstimator` 클래스의 `estimate` 메소드가 올바른 형태(shape)와 타입(`np.ndarray`)의 결과물을 반환하는지 검증한다. (모델 자체의 정확성이 아닌, 인터페이스의 유효성 검증)

### 3.2. 통합 테스트 (Integration Tests)

- **대상**: 여러 개의 클래스 또는 모듈이 함께 동작하는 시나리오. `ProcessingStep`들로 구성된 `Pipeline`의 일부 또는 전체가 해당된다.
- **목표**: 각 컴포넌트 간의 상호작용, 데이터 전달 및 인터페이스가 올바르게 작동하는지 검증한다. 실제 딥러닝 모델을 로드하여 실행할 수 있다.
- **예시**:
    - `EdgeDetectionStep`과 `DepthEstimationStep`을 연결한 파이프라인을 실행했을 때, `FrameContextBuilder`에 `edge_map`과 `depth_map`이 정상적으로 채워지는지 확인한다.
    - `LineTrackingStep`이 이전 프레임의 `line_registry`를 참조하여 현재 프레임의 라인 ID를 올바르게 부여하는지 검증한다.

### 3.3. 엔드투엔드 (E2E) / 회귀 테스트

- **대상**: `validation_script_3d.py`로 대표되는 전체 파이프라인.
- **목표**: 실제와 유사한 작은 샘플 비디오를 입력하여, 전체 시스템이 유기적으로 동작하는지 확인하고, 코드 변경 후에도 결과물의 일관성이 유지되는지(회귀 방지) 검증한다.
- **예시 (Golden Test)**:
    1.  `tests/data`에 있는 1초짜리 샘플 비디오를 전체 파이프라인에 입력한다.
    2.  최종적으로 생성된 `lines.json`의 일부 내용 또는 SSIM 같은 핵심 메트릭 값을 계산한다.
    3.  이 결과물을 미리 저장된 '정답(golden)' 파일/값과 비교하여 일치하는지 확인한다.
    4.  테스트가 통과하면, 이 테스트는 향후 모든 코드 변경 시마다 실행되어 기존의 결과물에 영향을 주지 않았음을 보장하는 강력한 회귀 테스트가 된다.

## 4. 완료의 정의 (Definition of Done - DoD)

하나의 기능 개발, 태스크, 또는 버그 수정 작업이 '완료'되었다고 판단하기 위한 체크리스트이다. 모든 코드는 Pull Request 제출 전에 아래 기준을 만족해야 한다.

- [ ] **코드 구현**: 요구된 기능의 코드가 작성되었는가?
- [ ] **단위 테스트**: 새로 추가되거나 수정된 코드 경로에 대한 단위 테스트가 작성되었으며, 모든 테스트(`pytest`)를 통과하는가?
- [ ] **코드 커버리지**: 전체 테스트 커버리지가 프로젝트 목표치(예: 85%) 이하로 떨어지지 않았는가? (`pytest --cov`)
- [ ] **통합/E2E 테스트**: 변경 사항과 관련된 통합/E2E 테스트 시나리오가 존재하며, 모두 통과하는가?
- [ ] **문서 업데이트**: 변경 사항이 관련 설계 문서(`docs/`)나 코드 주석(docstring)에 적절히 반영되었는가?
- [ ] **코드 리뷰**: 최소 1명 이상의 동료 개발자로부터 코드 리뷰를 받고, 제기된 주요 이슈들이 해결되었는가?
